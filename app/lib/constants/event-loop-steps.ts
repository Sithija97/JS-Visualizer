export type EventLoopStep = {
  step: number;
  description: string;
  callStack: string[];
  microtaskQueue: string[];
  callbackQueue: string[];
  output: string[];
  highlight: string;
  explanation: string;
};

export const EVENT_LOOP_STEPS: EventLoopStep[] = [
  {
    step: 0,
    description: "Initial state - Code starts executing",
    callStack: [],
    microtaskQueue: [],
    callbackQueue: [],
    output: [],
    highlight: "console.log('script start');",
    explanation: "Synchronous code begins execution",
  },
  {
    step: 1,
    description: "Execute: console.log('script start')",
    callStack: ["console.log('script start')"],
    microtaskQueue: [],
    callbackQueue: [],
    output: ["script start"],
    highlight: "console.log('script start');",
    explanation: "First synchronous console.log executes immediately",
  },
  {
    step: 2,
    description: "setTimeout() is called",
    callStack: ["setTimeout()"],
    microtaskQueue: [],
    callbackQueue: [],
    output: ["script start"],
    highlight: "setTimeout(() => { console.log('setTimeout'); }, 0);",
    explanation:
      "setTimeout sends callback to Web API, will move to Callback Queue after 0ms",
  },
  {
    step: 3,
    description: "setTimeout callback registered in Callback Queue",
    callStack: [],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: ["script start"],
    highlight: "setTimeout(() => { console.log('setTimeout'); }, 0);",
    explanation:
      "Callback is now waiting in the Callback Queue (Macrotask Queue)",
  },
  {
    step: 4,
    description: "async1() is called",
    callStack: ["async1()"],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: ["script start"],
    highlight: "async1();",
    explanation: "async1 function is pushed onto the call stack",
  },
  {
    step: 5,
    description: "Inside async1: console.log('async1 start')",
    callStack: ["async1()", "console.log('async1 start')"],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start"],
    highlight: "console.log('async1 start');",
    explanation: "First line of async1 executes synchronously",
  },
  {
    step: 6,
    description: "await async2() - calling async2()",
    callStack: ["async1()", "async2()"],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start"],
    highlight: "await async2();",
    explanation: "async2() is called and pushed onto stack",
  },
  {
    step: 7,
    description: "Inside async2: console.log('async2')",
    callStack: ["async1()", "async2()", "console.log('async2')"],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start", "async2"],
    highlight: "console.log('async2');",
    explanation: "async2 function body executes synchronously",
  },
  {
    step: 8,
    description: "await pauses async1, continuation goes to Microtask Queue",
    callStack: [],
    microtaskQueue: ["async1 continuation"],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start", "async2"],
    highlight: "await async2();",
    explanation:
      "Everything after 'await' becomes a microtask. async1 is paused.",
  },
  {
    step: 9,
    description: "new Promise executor runs (SYNCHRONOUS!)",
    callStack: ["Promise executor"],
    microtaskQueue: ["async1 continuation"],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start", "async2"],
    highlight: "new Promise((resolve) => { ... })",
    explanation: "Promise executor function runs immediately and synchronously",
  },
  {
    step: 10,
    description: "Inside Promise: console.log('promise1')",
    callStack: ["Promise executor", "console.log('promise1')"],
    microtaskQueue: ["async1 continuation"],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start", "async2", "promise1"],
    highlight: "console.log('promise1');",
    explanation: "Promise executor is synchronous, so this logs immediately",
  },
  {
    step: 11,
    description: ".then() callback added to Microtask Queue",
    callStack: [],
    microtaskQueue: ["async1 continuation", "promise2 callback"],
    callbackQueue: ["setTimeout callback"],
    output: ["script start", "async1 start", "async2", "promise1"],
    highlight: ".then(() => { console.log('promise2'); });",
    explanation: ".then() registers callback in Microtask Queue",
  },
  {
    step: 12,
    description: "Execute: console.log('script end')",
    callStack: ["console.log('script end')"],
    microtaskQueue: ["async1 continuation", "promise2 callback"],
    callbackQueue: ["setTimeout callback"],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
    ],
    highlight: "console.log('script end');",
    explanation: "Last synchronous code executes",
  },
  {
    step: 13,
    description: "Call Stack EMPTY! Event Loop processes Microtasks",
    callStack: [],
    microtaskQueue: ["async1 continuation", "promise2 callback"],
    callbackQueue: ["setTimeout callback"],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
    ],
    highlight: "EVENT LOOP STARTS",
    explanation:
      "Call stack is empty. Event loop will process ALL microtasks first",
  },
  {
    step: 14,
    description: "Process Microtask #1: async1 continuation",
    callStack: ["console.log('async1 end')"],
    microtaskQueue: ["promise2 callback"],
    callbackQueue: ["setTimeout callback"],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
      "async1 end",
    ],
    highlight: "console.log('async1 end');",
    explanation: "First microtask executes - code after await",
  },
  {
    step: 15,
    description: "Process Microtask #2: promise2 callback",
    callStack: ["console.log('promise2')"],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
      "async1 end",
      "promise2",
    ],
    highlight: "console.log('promise2');",
    explanation: "Second microtask executes - .then() callback",
  },
  {
    step: 16,
    description: "All Microtasks done! Process Macrotask",
    callStack: [],
    microtaskQueue: [],
    callbackQueue: ["setTimeout callback"],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
      "async1 end",
      "promise2",
    ],
    highlight: "EVENT LOOP: Macrotask",
    explanation: "Microtask queue empty. Event loop moves to Callback Queue",
  },
  {
    step: 17,
    description: "Execute setTimeout callback",
    callStack: ["console.log('setTimeout')"],
    microtaskQueue: [],
    callbackQueue: [],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
      "async1 end",
      "promise2",
      "setTimeout",
    ],
    highlight: "console.log('setTimeout');",
    explanation: "Macrotask (setTimeout callback) finally executes",
  },
  {
    step: 18,
    description: "COMPLETE! All queues empty",
    callStack: [],
    microtaskQueue: [],
    callbackQueue: [],
    output: [
      "script start",
      "async1 start",
      "async2",
      "promise1",
      "script end",
      "async1 end",
      "promise2",
      "setTimeout",
    ],
    highlight: "DONE",
    explanation: "Execution complete. This is the final output order.",
  },
];
